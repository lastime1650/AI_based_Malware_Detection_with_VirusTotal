'''

    분석 대상 확장자 마다 분석할 최종 json의 키 값 갯수는 다르다 !

    [EXE]:
            type_description // 파일 타입
            tlsh // ?
            vhash // 파일 해시
            type_tags // {}
            creation_date
            names
            last_modification_date
            type_tag
            times_submitted
            total_votes
            size
            popular_threat_classification
            authentihash
            detectiteasy
            last_submission_date
            reputation
            trid
            sha256
            type_extension
            tags
            last_analysis_date
            unique_sources
            first_submission_date
            sha1
            ssdeep
            md5
            pe_info
            magic
            last_analysis_stats
            last_analysis_results

'''

import json, hashlib, requests, struct
# process
# 파일의 해시 ( sha256을 먼저 구하고, 이미 스캔 이력이 있는 지 확인한다.
# 없으면? files 경로가 위치한 API에 요청을한다.
# 요청 후 status 가 queue ? 인가? 대기 후 다시 확인하는 작업을 하자.

class VirusTotal_class():
    def __init__(self, API_KEY:str ):
        self.API = API_KEY

    def Start_Scan(self, Path:str = None, Binary_DATA:bytes = None, Binary_DATA_SHA256:str = None) -> ( bool, list, bytes): # 결과, 결과(서버용), 결과(Rust 전송용)
        self.DATA:bytes

        hashed = ''
        if(Path):
            with open(Path, 'rb') as f:
                self.DATA = f.read()
            hashed = hashlib.sha256(self.DATA).hexdigest()  # 파일의 SHA256을 구함
        elif(Binary_DATA):
            self.DATA =  Binary_DATA
            hashed = Binary_DATA_SHA256
        else:
            print("경로 아니면 바이너리 값 중 하나만 하시오")
            return False,None,None


        #self.DATA = Binary_DATA

        #print(f"{Binary_DATA_SHA256} vs {hashed} 파일크기 -> {len(Binary_DATA)} vs {len(self.DATA)}")
        #if( Binary_DATA_SHA256!= None and Binary_DATA_SHA256 != hashed):
            #print("[Vt] 파라미터에서 제공된 DATA의 SHA256이 서로 다릅니다.")

            #return False,None,None

        # 먼저 HASH값으로 스캔 이력 확인
        status = requests.get(f"https://www.virustotal.com/api/v3/files/{hashed}", headers={"x-apikey": self.API})
        self.json_data = json.loads(status.text)
        print(f"스캔이력 보기 -> {self.json_data}")
        try:
            '''
               읽어올 수 없을 때, 즉 과거 스캔 이력이 없는 파일일 때 
            '''
            if ( "NotFoundError" != str(self.json_data["error"]["code"])):
                print("과거 스캔 이력이 있는 파일입니다. ")
                raise "a"
            else:
                '''
                    FILE 에 body 메서드로 api요청 후 analysis id 습득.
                    analysis id 로 analysis에 접근하여 분석 결과 확인 ( queue 이 후 여야 가능 ) 
                '''
                status = requests.post("https://www.virustotal.com/api/v3/files", headers={"x-apikey": self.API},files={"file": self.DATA})  # 분석을 위한 analyse id 값 얻기
                json_new_data = json.loads(status.text)
                print(json_new_data)
                analysis_id = str(json_new_data["data"]["id"])

                status = requests.get(f"https://www.virustotal.com/api/v3/analyses/{analysis_id}",headers={"x-apikey": self.API})
                json_new_data_analyse = json.loads(status.text)
                print(json_new_data_analyse)

                if ("queued" == str(json_new_data_analyse["data"]["attributes"]["status"])):

                    is_queued = True
                    while (is_queued):
                        status = requests.get(f"https://www.virustotal.com/api/v3/analyses/{analysis_id}",
                                              headers={"x-apikey": self.API})
                        json_new_data_analyse = json.loads(status.text)
                        if ("queued" == str(json_new_data_analyse["data"]["attributes"]["status"])):
                            print(f"여전히 queued입니다. {json_new_data_analyse}")
                        else:
                            is_queued = False
                status = requests.get(f"https://www.virustotal.com/api/v3/files/{hashed}", headers={"x-apikey": self.API})
                self.json_data = json.loads(status.text) # 이제 여기에 과거 분석된 정보가 담김
        except:
            print("Except!")
            self.json_data # 이미 여기에 과거 분석된 정보가 담김

            #return False, None
        finally:
            '''
                본격 추출
            '''
            print(self.json_data)


            result = self.Start_Analyse( hashed, self.json_data  ) # 결과 json을 분석한다 ( 리스트로 결과반환 )

            '''
                이제 RUst서버에 보낼 데이터로 만들어야겠지? list -> bytes ( 길이-기반 구조 )ㅋ
            '''
            result_but_length_Based_Bytes__For__Server = self.Build_Vt_result_for_Server(result) # list -> bytes

            '''
                검증원해? 
            '''
            self.already_Raw_DATA_parsing_for_TEST( result_but_length_Based_Bytes__For__Server )


            return True, result, result_but_length_Based_Bytes__For__Server

    def Start_Analyse(self, FILE_SHA256: str, data) -> list:

        '''
            Return_Bytes_results 정보
            [0] -> File_SHA256 ( 검증할거임 )
            [1] -> last_analysis_list
            [2] -> last_analysis_stats_list
            [3] ->
        '''
        Return_Bytes_results = []

        print(f" data -> {data['data']}")
        print(f" data/type -> {data['data']['type']}\n")

        print(f" data/attributes -> {data['data']['attributes']}")
        print(f" data/attributes/last_analysis_results -> {data['data']['attributes']['last_analysis_results']}")

        '''
            [0]
            파일 SHA256넣기

        '''

        if data['data']['attributes']['sha256'] == data['data']['id'] == FILE_SHA256:
            Return_Bytes_results.append([FILE_SHA256])
        else:
            return None

        print(f"\n\n\nReturn_Bytes_results -> {Return_Bytes_results}")

        '''
            [1]
            <last_analysis_results> - 2차원
            [0]: 엔진이름
            [1]: 탐지 카테고리 ( 악성여부 )
            [2]: 탐지결과 
        '''
        last_analysis_list = [['last_analysis_results']]  # 엔진 결과가 들어간다 들어간다 ( AI 훈련용 )

        for index, Analyser_Name in enumerate(data['data']['attributes']['last_analysis_results']):
            category = data['data']['attributes']['last_analysis_results'][Analyser_Name]['category']
            results = str(data['data']['attributes']['last_analysis_results'][Analyser_Name]['result']) if \
            data['data']['attributes']['last_analysis_results'][Analyser_Name]['result'] != None else "None"

            last_analysis_list.append([Analyser_Name, category, results])

        Return_Bytes_results.append(last_analysis_list)
        print("last_analysis_list -> ", last_analysis_list)

        '''
            [2]
            <last_analysis_stats>
            [o]malicious//
            [1]suspicious
            [2]undetected//
            [3]harmless
            [4]timeout/
            [5]confirmed-timeout
            [6]failure
            [7]type-unsupported ///
            
            [최근문제]
            Rust서버에서 "-"가 들어간 칼럼을 넣을 수 없음 확인. [해결방안] - 를 _로 변환해야한다.
        '''
        last_analysis_stats_list = [['last_analysis_stats_list']]  # 총 점수가 나옴
        for index, Analyse_stats in enumerate(data['data']['attributes']['last_analysis_stats']):
            last_analysis_stats_list.append( [Analyse_stats.replace("-","_"), str(data['data']['attributes']['last_analysis_stats'][Analyse_stats])] )

        Return_Bytes_results.append(last_analysis_stats_list)
        print('last_analysis_stats_list -> ', last_analysis_stats_list)

        '''
            [3] Results_Vote - 맬웨어 종합 투표
            
            [0]harmless
            [1]malicious
        '''
        total_votes_list = [['total_votes']]  # 총 점수가 나옴 ( key 값 도 넣는 이유는 Rust 서버의 파싱 특성이기 때문. -> for문안에 변수명 parse_status )
        for index, Analyse_total_votes in enumerate(data['data']['attributes']['total_votes']):
            total_votes_list.append(
                [Analyse_total_votes, str(data['data']['attributes']['total_votes'][Analyse_total_votes])])
        Return_Bytes_results.append(total_votes_list)

        '''
            [final]
        '''
        print(f"[최종]Return_Bytes_results -> {Return_Bytes_results}")

        return Return_Bytes_results


    def Build_Vt_result_for_Server(self, DATA) -> bytes:
        '''
            서버에 보내기 위해, '길이-기반'으로 평판 조회 결과를 제작한다
            {"_vt_"-시그니처 4바이트} + {길이4바이트 + Raw_DATA ( 동적 ) } + {"_END"}
        '''
        Return_Result_Bytes = '_vt_'.encode()

        for index, data in enumerate(DATA):
            '''
                1 case:
                    data -> [['SHA256'] - 2 ] - 1 ( 총 2차원 )
                2 case:
                    data -> [ ['','']-3,['','']... -2  ] - 1 ( 총 3차원 ) 
            '''
            if len(data) > 1:  # 2차원이 더 있는가?
                for index2, data2 in enumerate(data):
                    print(data2)
                    for index3, data3 in enumerate(data2):

                        try:
                            '''
                                data3에는 str, 혹은 int값이 나올 수 있다. 여기서 미리 bytes로 모두 변환하도록 한다
                            '''
                            if isinstance(data3, str):
                                data3:bytes = data3.encode()
                            elif isinstance(data3, int):
                                data3:bytes = self.int_to_4bytes( int(data3) )
                            else:
                                data3:bytes = bytes(data3)
                        except:
                            print("Server 데이터를 만드는데 처리할 수 없는 타입입니다!")
                            data3:bytes = b'None'

                        '''
                            메인 bytes 데이터에 {4바이트 길이} + {Raw_DATA} 를 지속적으로 축적하게 구현한다.
                        '''
                        Return_Result_Bytes = self.Build_length_andthen_Raw_DATA(Return_Result_Bytes, data3)

            elif len(data) == 1:  # 1차원인가?
                data = data[0]  # 1차원에 있는거 풀기
                data = data.encode() if isinstance(data, str) else bytes(data)
                Return_Result_Bytes = self.Build_length_andthen_Raw_DATA(Return_Result_Bytes, data)
            else:
                print("Vt - Parsing 오류 !")
                return b''

        Return_Result_Bytes += "_END".encode()
        return Return_Result_Bytes

    # 길이-기반에서 {길이-4바이트} + {Raw_Data}를 리턴한다
    def Build_length_andthen_Raw_DATA(self, Return_Result_Bytes: bytes, DATA: bytes) -> bytes:
        Return_Result_Bytes += self.int_to_4bytes(len(DATA))
        Return_Result_Bytes += DATA
        return Return_Result_Bytes

    # 서버에 보내는 데이터가 정상적으로 만들어졌는 지 검증하는 메서드
    def already_Raw_DATA_parsing_for_TEST(self, Return_Result_Bytes: bytes) -> bool:
        try:
            start_index = 0
            last_index = 4
            Vt_signature = Return_Result_Bytes[start_index:last_index].decode()
            print(f"Vt_signature -> {Vt_signature}")
            start_index = last_index
            last_index = last_index + 4

            while True:
                if Return_Result_Bytes[start_index: last_index] == b'_END':
                    break

                length = self.Bytes_to_int(Return_Result_Bytes[start_index: last_index])
                start_index = last_index
                last_index = last_index + length
                Raw_DATA = Return_Result_Bytes[start_index: last_index]
                start_index = last_index
                last_index = last_index + 4
                print(
                    f"length -> {length} / RAW_DATA -> {Raw_DATA.decode() if isinstance(Raw_DATA, str) else Raw_DATA}")
        except:
            return False
        return True

    # 변환기
    def int_to_4bytes(self, integer: int) -> bytes:
        return struct.pack('<I', integer)

    def Bytes_to_int(self, Data: bytes) -> int:
        return int((struct.unpack('<I', Data))[0])


'''url = 'C:\\DriverView.exe'
VirusTotal_class("b081a247f8bde7d98337dec2a44b9dff7d1eba19bd99a20c04395cea831177ee").Start_Scan(Path=url)'''