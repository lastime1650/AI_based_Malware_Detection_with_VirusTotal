import threading

import pefile

import PE_IMAGE_SIGNATRUEs
import numpy as np
import pickle
from Parsing_CSV import Open_Csv # CSV편집기
from virus_total_api import VirusTotal_class
from Vt_analyse_data_to_DeepLearning_data import Vt_analysed_List__To__DeepLearning_list # VT결과를 데이터세트로
def Make_y(original_y:list): # 리턴 -> [0]:칼럼리스트(predict용), [1]:one-hot인코드(Train용)
    ''' y 제작 '''

    y_column = []
    ''' 1. 고유한 데이터 추출 '''
    for i in original_y:
        if not (i in y_column):
            y_column.append(i)
    ''' 2. 원-핫 인코드 '''
    one_hot_encode = []
    for i in original_y:
        one_hot_encode_TMP = [0] * len(y_column)
        one_hot_encode_TMP[y_column.index(i)] = 1
        one_hot_encode.append(one_hot_encode_TMP)
    ''' 3. 결과 리턴 '''
    return y_column, one_hot_encode

def Get_X_from_EXE_bin(
        EXE_bin:bytes=None,
        loaded_x_for_dll_api_section_Malware:list=None ,
        Client_VT_instance:VirusTotal_class=None,
        SHA256:str=None, # 예측 대상 EXE SHA256
        SERVER_VT_CSV_MANAGER:Open_Csv=None
)->(list, bool): # 결과 값, 그리고 VT분석 성공했는지 여부

    if (len(EXE_bin) <4 ) or (EXE_bin == None):
        return None, None

    pe_image = None
    try:
        pe_image = pefile.PE(
            data=EXE_bin
        )
    except:
        print("PE 파싱 불가")
        return None, None

    ''' X 초기 생성'''
    X = [0] * len( loaded_x_for_dll_api_section_Malware )

    '''dll, api, section 추출'''
    tmp_DLL, tmp_API, tmp_SECTION = PE_IMAGE_SIGNATRUEs.Getting_Dll_API_SECTION(pe_image)
    collect = tmp_DLL + tmp_API + tmp_SECTION
    ''' 일치한 것에만 1 하기 '''
    for get_data in collect:  # 얻은거 하나씩 꺼내기


        if get_data in loaded_x_for_dll_api_section_Malware: # 일반
            X[  loaded_x_for_dll_api_section_Malware.index(get_data)    ] = 1  # [0]

        # malware 문자열 추출
        if str(get_data) + "malware" in loaded_x_for_dll_api_section_Malware:
            X[loaded_x_for_dll_api_section_Malware.index(str(get_data) + "malware")] = 1 # [1]


    '''고유추출 ( 이제부터 파라미터 x는 안씀 )'''
    X += PE_IMAGE_SIGNATRUEs.Getting_PE_HEADER(pe_image)  # [2]

    '''악성 문자열찾기 EXE바이너리->EXE_bin'''
    tmp_malware_strings = [0] * len(PE_IMAGE_SIGNATRUEs.signature_text)
    for signature_string in PE_IMAGE_SIGNATRUEs.signature_text:
        if signature_string in EXE_bin:
            tmp_malware_strings[PE_IMAGE_SIGNATRUEs.signature_text.index(signature_string)] = 1 #[3]

    X += tmp_malware_strings  # malware 문구 추가
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ''' VT 처리 '''
    is_success_VT_analyse = False
    SHA256 = SHA256
    GET_VT_row = SERVER_VT_CSV_MANAGER.Output_one_row(SHA256, 0)  # VT csv를 열어 같은 SHA256값이 "없"는 지 확인.
    if GET_VT_row == None:  # VT csv를 열어 같은 SHA256값이 "없"는 지 확인.
        print("이미 해당 EXE는 이전에 VT분석 이력이 '''''없'''''습니다.")
        try:

            # [1/3]
            result_bool, result_list, result_bytes = Client_VT_instance.Start_Scan(  # VT분석 시작 (Server전용 API로 한다)
                Binary_DATA=EXE_bin,
                Path=None,
                Binary_DATA_SHA256=SHA256  # 이것은 임시로 None
            )

            # [2/3]
            result_x_of_VT_analyse = Vt_analysed_List__To__DeepLearning_list(
                input_vt_list=result_list
            )

            # [3/3]
            '''CSV에 {vt}반영'''
            SERVER_VT_CSV_MANAGER.APPEND_row([SHA256] + result_x_of_VT_analyse)  # VT분석 결과 반영
            is_success_VT_analyse = True # VT 성공!
        except:
            print("VT api except! VTcsv의 데이터 길이(SHA256제외 길이) -> '937'를 모두 0으로 패딩합니다....")
            result_x_of_VT_analyse = [0] * 937
            is_success_VT_analyse = False # VT 실패!

    else:
        print("이미 해당 EXE는 이전에 VT분석 이력이 '''''있'''''습니다.")
        result_x_of_VT_analyse = GET_VT_row[1:len(GET_VT_row)]  # SHA256제외 모든 칼럼 ( VT분석데이터가 있음 ) 추출
        is_success_VT_analyse = True # VT 성공!

    X += result_x_of_VT_analyse
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    print(f"Prediction 최종 X길이 -> {len(X)}")
    result_X = np.asarray([X], dtype=object)
    return result_X, is_success_VT_analyse # 2차원+numpy_array 형태 만들어서 내보내기

def MAKING_x_y_for_TRAINNING(
        EXE_PATH_LIST_from_Main_csv:list=None,
        SAVE_INDEX:str=None,
        SAVE_LOCK:threading.Lock=None,
        Server_VT_instance:VirusTotal_class=None,
        SERVER_VT_CSV_MANAGER:Open_Csv=None

):

    '''[초기화,,] - 훈련될 EXE의 pefile.PE를 parameter를 통하여 추출한다. '''
    '''
        [EXE_PATH_LIST_from_Main_csv] 파라미터에는 어떤 정보가?...
        [0]: PATH
        [1]: SHA256
        [2]: y값
    '''
    Available_PE_list = [] # [0]: pe인스턴스, [1] EXE경로, [2] SHA256, [3] y값
    for index, data in enumerate( EXE_PATH_LIST_from_Main_csv ):
        try:
            #print(PATH)
            EXE_BIN:bytes = None
            with open(data[0], 'rb') as f:
                EXE_BIN = f.read()

            Available_PE_list.append(
                [pefile.PE(data=EXE_BIN), data[0], data[1], data[2]] # [0]: pe인스턴스, [1] EXE경로, [2] SHA256, [3] y값
            )

        except:
            print("[훈련]: Get_Xs_from_csv_with_EXE_Paths_for_TRAINNING -> PATH 열 수 없음.")
            continue

    '''[훈련 준비중,,] - 훈련될 EXE의 모든 DLL, API를 고유하게 수집한다. ->X데이터가 아닌, prediction때도 사용할 X칼럼을 만드는 것임 => 피클로 저장될 것.'''
    ALL_of_DLL_list = []
    ALL_of_API_list = []
    ALL_of_SECTION_list = []
    for index, PE_instance in enumerate(Available_PE_list):
        tmp_dll, tmp_api, tmp_section = PE_IMAGE_SIGNATRUEs.Getting_Dll_API_SECTION( PE_instance[0] )

        ''' 고유 DLL 추출 '''
        for dll_name in tmp_dll:
            if not ( dll_name in ALL_of_DLL_list ) :
                ALL_of_DLL_list.append(dll_name)

        ''' 고유 API 추출 '''
        for api_name in tmp_api:
            if not ( api_name in ALL_of_API_list ) :
                ALL_of_API_list.append(api_name)

        ''' 고유 SECTION 추출 '''
        for section_name in tmp_section:
            if not ( section_name in ALL_of_SECTION_list ) :
                ALL_of_SECTION_list.append(section_name)



    ''' [서브 주인공 X를 위한 칼럼(즉석 데이터세트)]'''
    column_for_X = ALL_of_DLL_list + ALL_of_API_list + ALL_of_SECTION_list + PE_IMAGE_SIGNATRUEs.pe_malware_api_signature

    ''' [찐 주인공 X!] -> 2차원 크기 -> 1차원=PE갯수 2차원=추출갯수'''
    X = []

    ''' [훈련 X 본격적 만들기] -> 추출한 DLL,API,SECTION등을 가지고 "초기 X 모양을 잡아야한다." '''
    for index, PE_instance in enumerate(Available_PE_list):
        tmp_x = [0] * len(column_for_X)

        tmp_dll, tmp_api, tmp_section = PE_IMAGE_SIGNATRUEs.Getting_Dll_API_SECTION(PE_instance[0])
        tmp_all =  tmp_dll + tmp_api + tmp_section# 한번에 뭉쳐

        for get_data in tmp_all: # 얻은거 하나씩 꺼내기

            if get_data in column_for_X:
                tmp_x[column_for_X.index(get_data)] = 1 # [0]


            ''' [+] malware API 추출 (이전에 이것이 반영되지 않았었음 원인: 중복된 문자열로 malware API에는 아예 0만됨 )'''

            if str(get_data)+"malware" in column_for_X:
                tmp_x[column_for_X.index(   str(get_data)+"malware" )] = 1 # [1]
        print(f"tmp_all 후 ,, tmp_x길이 -> {len(tmp_x)}")

        ''' 이제 초기 X 는 잡음. 이제부터는 PE 헤더를 전수조사하여 추출한다. '''
        tmp_x += PE_IMAGE_SIGNATRUEs.Getting_PE_HEADER(PE_instance[0]) # [2]


        print(f"Getting_PE_HEADER 후 ,, tmp_x길이 -> {len(tmp_x)}")

        tmp_malware_strings = [0] * len( PE_IMAGE_SIGNATRUEs.signature_text )
        with open(PE_instance[1], 'rb') as f:
            EXE = f.read()
            for signature_string in PE_IMAGE_SIGNATRUEs.signature_text:
                if signature_string in EXE :
                    tmp_malware_strings[ PE_IMAGE_SIGNATRUEs.signature_text.index(signature_string)  ] = 1

        tmp_x += tmp_malware_strings # malware 문구 추가

        print(f"signature_text 후 ,, tmp_x길이 -> {len(tmp_x)}")
        ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        '''[VT분석영역]'''
        # SHA256기준, 이미 VT분석 정보가 CSV에 있는가?
        SHA256:str = PE_instance[2] # SHA256가져옴
        GET_VT_row = SERVER_VT_CSV_MANAGER.Output_one_row(SHA256, 0) # VT csv를 열어 같은 SHA256값이 "없"는 지 확인.
        if GET_VT_row == None: # VT csv를 열어 같은 SHA256값이 "없"는 지 확인.
            print("이미 해당 EXE는 이전에 VT분석 이력이 '''''없'''''습니다.")
            try:

                #[1/3]
                result_bool, result_list, result_bytes = Server_VT_instance.Start_Scan( # VT분석 시작 (Server전용 API로 한다)
                    Binary_DATA=None,
                    Path=PE_instance[1],
                    Binary_DATA_SHA256=SHA256  # 이것은 임시로 None
                )

                #[2/3]
                result_x_of_VT_analyse = Vt_analysed_List__To__DeepLearning_list(
                    input_vt_list=result_list
                )

                # [3/3]
                '''CSV에 {vt}반영'''
                SERVER_VT_CSV_MANAGER.APPEND_row([SHA256] + result_x_of_VT_analyse)  # VT분석 결과 반영

            except:
                print("VT api except! VTcsv의 데이터 길이(SHA256제외 길이) -> '937'를 모두 0으로 패딩합니다....")
                result_x_of_VT_analyse = [0] * 937

        else:
            print("이미 해당 EXE는 이전에 VT분석 이력이 '''''있'''''습니다.")
            result_x_of_VT_analyse = GET_VT_row[1:len(GET_VT_row)] # SHA256제외 모든 칼럼 ( VT분석데이터가 있음 ) 추출

        tmp_x += result_x_of_VT_analyse
        ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



        print(tmp_x)
        X.append(tmp_x)

    ''' X 최종 만들기 -> numpy로 변환 '''
    result_X = np.asarray(X, dtype=object)
    print(result_X)

    ''' y 만들기 ( 원-핫 인코드 ) '''
    column_y, one_hot_encode_y = Make_y( [ i[3] for i in  Available_PE_list] )
    #print(Make_y( [ i[3] for i in  Available_PE_list] ))
    result_y = np.array(one_hot_encode_y)


    with SAVE_LOCK:
        # 훈련에 사용한 X 추출 데이터 세이브 ( dll, api 임 )
        with open(f"{SAVE_INDEX}_x", 'wb') as f:
            pickle.dump(column_for_X, f, protocol=5)
        # 훈련에 추출한 y 칼럼 세이브
        with open(f"{SAVE_INDEX}_y", 'wb') as f:
            pickle.dump(column_y, f, protocol=5)



    return result_X, result_y


'''import os
GET_FILES = []
for path, direct, files in os.walk("."):
    for i in files:
        if ".exe" in i:
            GET_FILES.append(i)
#print(len(GET_FILES))
#TEST_EXE = ["7dcd092a0fa5cd23c50214e8fb6c0c267ed3f8f1bf0ee8881a2f18d7b356fe72.exe"]
Get_Xs_from_csv_with_EXE_Paths_for_TRAINNING(GET_FILES)'''

